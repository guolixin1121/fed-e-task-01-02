# 函数式编程
**函数式编程**（Functional Programming， FP）是编程范式之一，此外的编程范式有**面向过程编程**、**面向对象编程**

**面向过程编程**：按照逻辑一步一步编写逻辑
**面向对象编程**：把现实生活中事物抽象成程序世界中的类和对象，通过封装、继承、多态来映射事物事件的联系（对事物的抽象）
**面向函数编程**：把现实生活中事物与事物之间的联系抽象到程序中的映射关系（对运算过程的抽象）

## 高阶函数 （Higher-Order Function）
**高阶函数**
函数作为参数或返回值
**使用的意义**
1. 抽象可以帮助屏幕细节，只关注目标需求
2. 抽象通用的问题

## 闭包
可以在另一个作用域内调用一个函数的内部函数并访问到该函数作用域内的成员

**注意事项**
因为外部可能会引用到函数内部作用域的对象，可能会引发内存无法释放，从而引发内存泄露

## 纯函数
相同的输入始终得到相同的输出，且无副作用

**优势**
1. 因为输出固定，所以可缓存其结果
2. 可测试
3. 并行处理
   多线程环境下并行操作共享内存时会出现意外，而纯函数不需要访问共享内存，所以可任意使用(web worker)

## 柯里化
对函数参数进行缓存，将多元函数变成一元函数
将函数的粒度变小，使函数变的更加灵活

## 函数组合
**函数组合**：如果一个函数需要经过多个函数处理才能得到最终值，这时可以把中间过程和函数合并为一个函数。
将细粒度的多个函数重新组合成一个新函数，避免洋葱式的层级函数调用，如_.add(_.first(_.reverse(data)))
```fn = compose(f1, f2, f3)```

## Point Free模式
对运算过程的合成   
无需指定参数数据   
需要一些基本运算函数作为辅助函数

## 函子Functor
解决的问题： 将函数的副作用包含在函数内，比如异常处理、异步操作等

**Functor**
一个容器函数（一般通过class实现）   
构造函数接受一个值，存储在内部     
具有map方法，用于对值进行处理（变形关系）  
想要操作值，需要将函数传递给map  
map返回一个函子对象   

**Container**
封装一个函子容器

**Maybe函子**
对外部传的空值做处理   
isNothing? this: map

**Either函子**
对异常做处理

**IO函子**
函数的值是一个函数，而不是普通值   
将不纯函数变为纯函数   

**Task函子**
处理异步

**Pointed函子**
Pointed函子是实现了of静态方法的函子   
将value包含在上下文中，处理值在这个上下文中(map)   